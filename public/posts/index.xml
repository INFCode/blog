<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Infcode&#39;s Blog</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Infcode&#39;s Blog</description>
    <generator>Hugo -- 0.134.1</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 Jul 2024 19:53:42 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Traps in &#34;for-loop&#34;s: A Deep Dive into Range-Based Loops and Variable Handling</title>
      <link>http://localhost:1313/posts/loop-rust-golang/</link>
      <pubDate>Wed, 31 Jul 2024 19:53:42 -0400</pubDate>
      <guid>http://localhost:1313/posts/loop-rust-golang/</guid>
      <description>&lt;p&gt;Rust and Go are two modern programming languages that have made significant impacts in their respective domains. Rust shines in system programming, with a focus on memory safety without a garbage collector, while Go excels in simplicity and concurrent programming. Despite both being relatively young, these languages have key differences, even in how they handle range-based loops and loop variables.&lt;/p&gt;
&lt;p&gt;In this blog post, we’ll explore how Rust and Go differ in their treatment of loop variables, and a subtle but significant change introduced in Go 1.22. Even seasoned developers can stumble over these nuances, but understanding them can save you hours of debugging.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fix &#34;Partition /boot is too full&#34; Error on Linux</title>
      <link>http://localhost:1313/posts/boot-is-too-full/</link>
      <pubDate>Wed, 22 May 2024 22:53:35 -0400</pubDate>
      <guid>http://localhost:1313/posts/boot-is-too-full/</guid>
      <description>&lt;h2 id=&#34;saving-space-on-your-boot-partition&#34;&gt;Saving Space on Your /boot Partition&lt;/h2&gt;
&lt;p&gt;I recently ran into trouble because I followed the old advice of allocating only ~200MB for the &lt;code&gt;/boot&lt;/code&gt; partition. While this might have been a reasonable choice a decade ago, when files were smaller and disk space was more expensive, it’s no longer sufficient for modern systems. On top of that, I’m dual-booting with Windows, which further complicates disk space management.&lt;/p&gt;
&lt;p&gt;Anyway, that&amp;rsquo;s the situation I faced. The next question was: how do I fix this? After searching online, I found several recommendations that suggested deleting &lt;code&gt;initramfs-linux-fallback.img&lt;/code&gt; to free up space. While it’s a large file and might seem unnecessary, it’s not advisable to remove it without understanding its purpose.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
